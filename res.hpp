#include "cube/cube_model.hpp"
#include "cube/cube_normals.hpp"
#include "cube/cube_uv.hpp"
#include "cube/cube_texture.hpp"
#include "cube/cubespec_texture.hpp"

#include "models/gauss_model.hpp"
#include "models/gauss_normals.hpp"
#include "models/gauss_uv.hpp"
#include "models/gauss_texture.hpp"

#include "monitor/monitor_model.hpp"
#include "monitor/monitor_normals.hpp"
#include "monitor/monitor_uv.hpp"

#include "plane/plane_model.hpp"
#include "plane/plane_normals.hpp"
#include "plane/plane_uv.hpp"

const char* vertexShaderCode =
                    "#version 400\n"
                    "layout (location = 0) in vec3 positions;" 
                    "layout (location = 1) in vec3 normals;" 
                    "layout (location = 2) in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshx;" 
                    "uniform mat4 meshy;" 
                    "uniform mat4 meshz;" 
                    "uniform mat4 meshs;" 

                    "uniform mat4 sproj[10];" 
                    "uniform mat4 stranslate[10];" 
                    "uniform mat4 sxrot[10];" 
                    "uniform mat4 syrot[10];" 

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions, 1.0f);" 
                    "  tr = meshm * meshx * meshy * meshz * tr;" 
                    "  gl_Position = proj * xrot * yrot * translate * tr;" 
                            "fuv = uv;"
                            "fnormals = mat3(transpose(inverse(mat4(1.0f)))) * normals;"
                            "fpos = vec3(mat4(1.0f) * vec4(positions, 1.0f));"
                            "projlightmat = sproj[0] * sxrot[0] * syrot[0] * stranslate[0] * tr;"
                    "}";

const char* vertexgShaderCode =
                    "#version 400\n"
                    "layout (location = 0) in vec3 positions;" 
                    "layout (location = 1) in vec3 normals;" 
                    "layout (location = 2) in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshx;" 
                    "uniform mat4 meshy;" 
                    "uniform mat4 meshz;" 
                    "uniform mat4 meshs;" 

                    "uniform mat4 sproj[10];" 
                    "uniform mat4 stranslate[10];" 
                    "uniform mat4 sxrot[10];" 
                    "uniform mat4 syrot[10];" 

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "void main() {" 
                    "  gl_Position = proj * vec4(positions, 1.0f);" 
                            "fuv = uv;"
                            "fnormals = mat3(transpose(inverse(mat4(1.0f)))) * normals;"
                            "fpos = vec3(mat4(1.0f) * vec4(positions, 1.0f));"
                            "projlightmat = sproj[0] * sxrot[0] * syrot[0] * stranslate[0] * vec4(positions, 1.0f);"
                    "}";

const char* fragmentShaderCode =
                    "#version 400\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "float shadowMapping(){" 
                    "  vec3 projected = projlightmat.xyz / projlightmat.w;" 
                    "  float shadow = 0.0f;" 
                    "  if(projected.z <= 1.0f){" 
                    "   projected = (projected + 1.0f)/2.0f;" 
                    "   float closestDepth = texture(shadowMap0, projected.xy).r;" 
                    "   float currentDepth = projected.z;" 
                    "   if(currentDepth - 0.0001 > closestDepth){" 
                    "       shadow+=1.0f;" 
                    "   }" 
                    "  }" 
                    "  return shadow;" 
                    "}" 
                    "float phongl(vec3 lightpos){" 
                    "  float ambient = 0.1;" 
                    "  vec3 norm = normalize(fnormals);" 
                    "  vec3 ldir = normalize(lightpos-fpos);" 
                    "  float diffuse = max(dot(norm, ldir), 0.0);" 
                    "  vec3 viewDir = normalize(-viewPos - fpos);" 
                    "  vec3 halfwayDir = normalize(ldir + viewDir);" 
                    "  float spec = pow(max(dot(norm, halfwayDir), 0.0), 16.0) * texture(spec1, fuv).r;" 
                    "  return float((spec + diffuse)*(1.0-shadowMapping())) + ambient;" 
                    "}" 
                    "void main() {" 
                    "  vec3 toOut = phongl(lightsPos[0]) * lightsCol[0] * texture(tex1, fuv).rgb;" 
                    "  color = vec4( toOut, 1.0);" 
                    "}";

const char* fragmentShaderCode2 =
            "#version 400\n" 
                    "precision mediump float;" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "layout(location = 0) out vec4 color;"
                    "void main() {" 
                    "  color = vec4(texture(shadowMap0, fuv).rrr, 1.0);" 
                    "}";

const char* vertexuiShaderCode =
                    "#version 400\n"
                    "layout (location = 0) in vec3 positions;" 
                    "layout (location = 1) in vec3 normals;" 
                    "layout (location = 2) in vec2 uv;" 
                    "uniform mat4 proj;" 
                    "uniform vec2 res;" 
                    "uniform mat4 translate;" 
                    "uniform mat4 xrot;" 
                    "uniform mat4 yrot;" 
                    "uniform mat4 meshm;" 
                    "uniform mat4 meshs;"  

                    "out vec2 fuv;"
                    "out vec3 fnormals;"
                    "out vec3 fpos;"
                    "out vec4 projlightmat;"
                    "void main() {" 
                    "  vec4 tr = meshs * vec4(positions.xy/res.xy, 0, 1.0f);" 
                    "  gl_Position = meshm * tr;" 
                            "fuv = vec2(uv.x, uv.y);"
                    "}";

const char* fragmentuiShaderCode =
                    "#version 400\n" 
                    "uniform sampler2D tex1;"
                    "uniform sampler2D spec1;"
                    "uniform sampler2D shadowMap0;"
                    "uniform vec3 lightsPos[10];"
                    "uniform vec3 lightsCol[10];"
                    "uniform int lightStates[10];"
                    "uniform vec3 viewPos;"
                    "in vec4 projlightmat;"
                    "in vec2 fuv;"
                    "in vec3 fnormals;"
                    "in vec3 fpos;"
                    "layout(location = 0) out vec4 color;"
                    "void main(){"
                    "  color = vec4( 0.0, 1.0, 0.0, 1.0);" 
                    "}";